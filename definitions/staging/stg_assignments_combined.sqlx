config {
    type: "incremental",
    schema: "c_forecast_dev",
    name: "stg_assignments_combined_filtered",
    tags: ['Sweden', 'Norway'],
    uniqueKey: ['id'],
    bigquery: {
        partitionBy: "DATE(CAST(updated_at AS TIMESTAMP))"
    }
}

SELECT 
    combined_data.id,
    combined_data.start_date,
    combined_data.end_date,
    combined_data.allocation,
    combined_data.notes,
    CAST(combined_data.updated_at AS STRING) AS updated_at,
    combined_data.updated_by_id,
    combined_data.project_id,
    combined_data.person_id,
    combined_data.placeholder_id,
    combined_data.repeated_assignment_set_id,
    combined_data.active_on_days_off
FROM (
    SELECT 
        id,
        start_date,
        end_date,
        allocation,
        notes,
        CAST(updated_at AS STRING) AS updated_at,
        updated_by_id,
        project_id,
        person_id,
        CAST(placeholder_id AS STRING) AS placeholder_id,
        CAST(repeated_assignment_set_id AS STRING) AS repeated_assignment_set_id,
        active_on_days_off
    FROM ${ref("forecast_se_assignments")}

    UNION ALL

    SELECT 
        id AS forecast_person_id,
        start_date,
        end_date,
        allocation,
        notes,
        CAST(updated_at AS STRING) AS updated_at,
        updated_by_id,
        project_id,
        person_id,
        CAST(placeholder_id AS STRING) AS placeholder_id,
        CAST(repeated_assignment_set_id AS STRING) AS repeated_assignment_set_id,
        active_on_days_off
    FROM ${ref("forecast_no_assignments")}
) AS combined_data
WHERE EXISTS (
    SELECT 1
    FROM ${ref("stg_people_combined")} AS employees
    WHERE employees.forecast_person_id = combined_data.person_id
)
${when(incremental(), `AND (
    CAST(combined_data.updated_at AS TIMESTAMP) > (SELECT CAST(MAX(updated_at) AS TIMESTAMP) FROM ${self()})
    OR CAST(combined_data.updated_at AS TIMESTAMP) >= TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 3 DAY)
    OR combined_data.id NOT IN (SELECT id FROM ${self()})
)`)}
